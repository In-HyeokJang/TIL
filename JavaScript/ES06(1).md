# ES6 문법 정리(1)

https://github.com/lukehoban/es6features 와 [MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide) 을 참고하여 ES6 문법을 정리해보고자 한다.

# 목차

- [1. Arrow function](#1-arrow-function)
- [2. Classes](#2-classes)
- [3. Enhanced Object Lieral](#3-enhanced-object-literal)

# 1. Arrow function

arrow function은 화살표 함수라고도 한다. function 키워드 대신 `=>` 키워드를 사용해서 보다 간략한 방법으로 함수를 선언할 수 있게 해준다.

## 1 -1 . **화살표 함수의 기본적인 형태**

```js
const elemets = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

elements.map(function (element) {
  return element.length;
});
// [8, 6, 7, 9]

// arrow function
// 파라미터가 하나면 괄호 생략 가능하다.
elements.map((element) => {
  return element.length;
});

// return 문이 한 줄이면 return과 중괄호 ({}) 생략 가능하다.
elements.map((element) => element.length);
```

## 1 -2. **Arrow Function에서의 `this`**

Arrow Function에서의 `this`는 함수가 **선언될 때 정적으로 바인딩** 된다.

동적으로 결정되는 일반 함수와는 달리 Arrow Function의 `this`는 언제나 **상위 스코프의 `this`** 를 가리킨다. (`Lexical this`)

아래의 코드는 `this`를 `print` 메소드 내부에서, 그리고 `print` 메소드 내부의 `forEach` 안에서 접근하고 있다.

`print`메소드 내부의 `this`는 `obj`를 가리코고 있어 정상적으로 출력이 되지만 `forEach` 내부의 `this`는 `window`를 가리코기 있기 때문에 `undefined`가 출력 된다.

```js
let obj = {
  names: ["A", "B"],
  text: "님 안녕하세요",
  print: function () {
    console.log(this.text); //님 안녕하세요
    this.names.forEach(function (name) {
      console.log(name + this.text);
    });
  },
};
obj.print();
// 님 안녕하세요.
// Aundefined
// bundefinde
```

`forEach`를 화살표 함수로 바꾸면 상위 스코프의 `this` 즉 , `obj`를 가리킬 수 있다.

```js
let obj = {
    names: ["A","B"],
    text: "님 안녕하세요."
    print: function(){
        consloe.log(this.text)			//님 안녕하세요.
    	this.names.forEach((name) => { // 화살표 함수는 바로 바깥 범위에서 `this`를 찾는것으로 검색을 끝내게 됩니다.
        	console.log(name + this.text)
    	})
    }
}
obj.print()
//님 안녕하세요.
//A님 안녕하세요.
//B님 안녕하세요.
```

arrow function에 대한 더욱 자세한 설명은 여기 [MDN - arrow functioin](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

# 2. Classes

`class`란 객체를 만드는 공장이라고 할 수 있다.

`class`가 나오기 전에는 객체를 만들 때 생성자 함수를 사용해서 만들 수 있었다.

```js
fucntion Person(name, first, second){
    this.name = name;
    this.first = fisrt;
    this.second = second;
}
let shim = new Person('shim', 10, 20);
console.log('shim',shim);

//person{name:"shim", first:10, second:20}
```

**class의 특징**

객체를 만들기 위한 템플릿으로 생성자 함수와 `class`를 사용할 수 있다. 그럼 어떤 차이점이 있는지 한 번 알아보자.

- `class`에는 객체가 만들어지기 직전에 실행되도록 약속되어진`constructor`라는 함수가 존재한다. 이 함수를 이용해서 객체의 초기값을 설정 할 수 있다.
- `getter`와`setter`를 사용할 수 있다.

```js
class Person {
  constructor(age) {
    tihs.age = age;
  }
  get age() {
    return this._age;
  }
  set age(value) {
    this._age = value < 0 ? "0이상의 값을 입력해주세요" : value;
  }
}
let shim = new Person(-1);
console.log(shim);
//0이상의 값을 입력해주세요.
```

- `class`로 만든 함수에는 특부 내부 프로퍼티인

  `[[FunctionKind]]:"classConstructor"`가 존재한다. 자바스크립트는 이 프로퍼티를 확인하는 검증 과정이 있기 때문에 클래스를 `new`키워드와 같이 사용하지 않으면 에러가 발생한다.

- `class`는 항상 `use strict`모드로 실행된다.

class에 대한 더욱 자세한 설명은 여기 [MDN - class](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)

# 3. Enhanced Object Literal
